{"mappings":"AAAA,MAAMA,EAAQ,CACZC,KAAM,CACJC,KAAM,IAaRC,UAAW,GAEXC,WACE,OAAOC,KAAKJ,MAEdK,SAASC,GAEPF,KAAKJ,KAAOM,EAGZ,IAAK,MAAMC,KAAMH,KAAKF,UACpBK,KAGJC,UAAUC,GAERL,KAAKF,UAAUQ,KAAKD,IAMtBE,QAAQC,GAGN,MAAMC,EAAKT,KAAKD,WAChB,IAAIW,EAAWD,EAAGZ,KAAKc,OACvBH,EAAKI,IAAMF,EAGXD,EAAGZ,KAAKS,KAAKE,GAEbR,KAAKC,SAASQ,IAKhBI,sBAEE,OADoBb,KAAKD,WACNF,KAAKiB,QAAQC,GAAmB,GAAbA,EAAEC,aClD5C,WAeE,GAdArB,EAAMS,WAAU,KACd,MAAMa,EAActB,EAAMI,WACpBmB,EAAoBC,KAAKC,UAAUH,EAAYpB,MACrDwB,aAAaC,QAAQ,cAAeJ,GAEpCK,QAAQC,IAAIH,aAAaI,QAAQ,mBCR9B,WACL,MAAMC,UAAuBC,YAIhBC,gCACT,MAAO,CAAC,eAAgB,cAAe,cAAe,UAGxDC,OAAS7B,KAAK8B,aAAa,CAAEC,KAAM,SAEnCC,cAEEC,QACAjC,KAAKkC,SAIPA,SACE,IAAIC,EAAQC,SAASC,cAAc,SACnCF,EAAMG,YAAc,swCAmJlBT,OAAAU,UAAA,gSAWF,MAAAC,EAAexC,KAAK6B,OAACY,cAAA,UACtBD,EAAAE,iBAAA,SAAAC,IAED,MAAAC,EAAoBJ,EAAGC,cAAA,gBACrBI,EAAAL,EAAAC,cAAA,gBACDG,EAAAT,MAAAW,WAAA,UAEDN,EAAeL,MAAGY,gBAAA,aAChBF,EAAAV,MAAAa,MAAA,gBAuBFhD,KAAA6B,OAAAY,cAAA,gBACAC,iBAAA,SAAAC,IAIA,GAAA,GAHqBA,EAAAM,OAGrBC,QAAA,CACA,MAAAtC,EAAAZ,KAAAmD,aAAA,82BD5MFC,GACkBhB,SAASK,cAAc,mBAC/BY,YEZL,WAEL,MAAMC,EAAMlB,SAASC,cAAc,cACnCiB,EAAIf,UAAY,+ZAmCZnC,WAAA,WACAmD,EAAAnB,SAAAK,cAAA,yBAEAc,EAAMC,YAAaD,EAASE,YAAcF,EAAOC,kBAMjD5D,EAASD,EAAyBkB,sBAEnC,IAAA,MAAA6C,KAAA9D,EAAA,CAGH,MAAA+D,EAAAD,EAAAE,MACAC,EAAAH,EAAAG,WACa7C,EAAI0C,EAAa1C,QACzBJ,EAAA8C,EAAiB9C,IAKbkD,EAAY1B,SAAUC,cAAA,OAC3ByB,EAAUvB,UAAO,6CACHoB,mBAAAE,mBAAA7C,cAAAJ,6CAIf2C,EAAAF,YAAAS,iKFtDmBC,IAEtBxC,QAAQC,IAAIH,aAAaI,QAAQ,gBAEUuC,MAAvC3C,aAAaI,QAAQ,oBAClB,CACL,MAAMwC,EAAmB,CAAEpE,KAAM,IACjCoE,EAAiBpE,KAAOsB,KAAK+C,MAAM7C,aAAaI,QAAQ,gBACxD9B,EAAMM,SAASgE,IAGnBE","sources":["src/state.ts","src/index.ts","src/components/element-tarea.ts","src/pages/mi-lista/index.ts"],"sourcesContent":["const state = {\r\n  data: {\r\n    list: [],\r\n  },\r\n  //lista va a ser un array de tareas\r\n  // tarea va a ser una objeto del siguiente tipo\r\n  // tarea = {\r\n  //  codigo: number,\r\n  //  texto: String,\r\n  //  completada: boolean,\r\n  //  borrada: boolean,\r\n  //};\r\n\r\n  //el listener es un array de funciones, que van a hacer algo cuando\r\n  //cambie el state\r\n  listeners: [], // los callbacks\r\n\r\n  getState() {\r\n    return this.data;\r\n  },\r\n  setState(newState) {\r\n    // modifica this.data (el state) e invoca los callbacks\r\n    this.data = newState;\r\n    //cb de callback\r\n    //cada vez que se modifica el state se ejecutan los cb suscriptos\r\n    for (const cb of this.listeners) {\r\n      cb();\r\n    }\r\n  },\r\n  subscribe(callback: (any) => any) {\r\n    // recibe callbacks para ser avisados posteriormente\r\n    this.listeners.push(callback);\r\n  },\r\n\r\n  //siempre que modifico el state, primero debo traerme el ultimo state\r\n  //luego modifico el state y por ultimo hago el setState, para decir\r\n  //los cambios que hubo\r\n  addItem(item) {\r\n    // suma la nueva tarea a la lista\r\n    // este item va a ser un objeto con las caracteristicas nombradas\r\n    const cs = this.getState(); //me trago el ultimo state\r\n    let posicion = cs.list.length;\r\n    item.cod = posicion; //el cod que sera nuestro codigo unico\r\n    //esta establecido por la posicion de la tarea en el array list\r\n\r\n    cs.list.push(item); //modifico list agregando la nueva tarea\r\n\r\n    this.setState(cs); //cargo el nuevo state\r\n  },\r\n\r\n  //verifica cuales tareas estan borradas y devuelve las no borradas\r\n  //asi posteriormente solo renderizar las que no fueron borradas\r\n  getTareasNoBorradas() {\r\n    const ultimoState = this.getState();\r\n    return ultimoState.list.filter((t) => t.borrada == false);\r\n  },\r\n};\r\n\r\nexport { state };\r\n","import { initMiLista } from \"./pages/mi-lista/index\";\r\nimport { init as initElementTareaEl } from \"./components/element-tarea\";\r\nimport { state } from \"./state\";\r\n\r\nfunction main() {\r\n  state.subscribe(() => {\r\n    const actualState = state.getState();\r\n    const tareasStingifeado = JSON.stringify(actualState.list);\r\n    localStorage.setItem(\"listaTareas\", tareasStingifeado);\r\n\r\n    console.log(localStorage.getItem(\"listaTareas\"));\r\n  });\r\n\r\n  initElementTareaEl();\r\n  const container = document.querySelector(\".container-page\");\r\n  container.appendChild(initMiLista());\r\n\r\n  console.log(localStorage.getItem(\"listaTareas\"));\r\n\r\n  if (localStorage.getItem(\"listaTareas\") == undefined) {\r\n  } else {\r\n    const listaTareasLocal = { list: [] };\r\n    listaTareasLocal.list = JSON.parse(localStorage.getItem(\"listaTareas\"));\r\n    state.setState(listaTareasLocal);\r\n  }\r\n}\r\nmain();\r\n","import { state } from \"../state\";\r\n\r\nexport function init() {\r\n  class ElementTareaEl extends HTMLElement {\r\n    // Specify observed attributes so that\r\n    // attributeChangedCallback will work\r\n    //estos son los atributos que voy a estar obsevando su cambios\r\n    static get observedAttributes() {\r\n      return [\"textoMostrar\", \"estaChecked\", \"estaBorrado\", \"codigo\"];\r\n    }\r\n\r\n    shadow = this.attachShadow({ mode: \"open\" });\r\n\r\n    constructor() {\r\n      // Always call super first in constructor\r\n      super();\r\n      this.render();\r\n    }\r\n\r\n    //creo el style del customElement\r\n    render() {\r\n      let style = document.createElement(\"style\");\r\n      style.textContent = `\r\n      .tarea {\r\n        font-family: \"Poppins\", sans-serif;\r\n        font-size: 18px;\r\n        display: flex;\r\n        min-width: 311px;\r\n        min-height: 122px;\r\n        max-width: 400px;\r\n        background-color: greenyellow;\r\n        flex-direction: column;\r\n        padding: 22px 13px;\r\n        justify-content: space-between;\r\n        border: solid black 2px;\r\n        margin: 20px auto;\r\n      }\r\n      \r\n      .tarea-container-labelinput {\r\n        display: flex;\r\n        width: 100%;\r\n        flex-direction: row;\r\n        justify-content: space-between;\r\n      }\r\n      \r\n      .tarea-label {\r\n        align-items: center;\r\n      }\r\n      \r\n      .tarea-input {\r\n        min-width: 20px;\r\n        min-height: 20px;\r\n        max-width: 30px;\r\n        max-height: 30px;\r\n        align-items: center;\r\n      }\r\n      \r\n      .tarea-boton {\r\n        font-family: \"Poppins\", sans-serif;\r\n        width: 80px;\r\n        height: 40px;\r\n        align-self: flex-end;\r\n        border-radius: 5px;\r\n        background-color: #5ae3fc;\r\n        color: black;\r\n        visibility: hidden;\r\n      }\r\n      \r\n      .tarea-label.true {\r\n        text-decoration: line-through;\r\n      }\r\n      \r\n      .tarea-label.false {\r\n        text-decoration: none;\r\n      }\r\n                `;\r\n      // tarea:{\r\n      //    codigo: number,\r\n      //    nombre: string,\r\n      //    completada: boolean,  true--> completada , false-->pendiente\r\n      //    borrada: boolean\r\n      //}\r\n\r\n      //creo la estructura del customElement\r\n      this.shadow.innerHTML = `\r\n      <div class=\"tarea\">\r\n          <div class=\"tarea-container-labelinput\">\r\n              <label class=\"tarea-label\"> </label>\r\n              <input class=\"tarea-input\" type=\"checkbox\" />\r\n          </div>\r\n          <button class=\"tarea-boton\">Eliminar</button>\r\n      </div>\r\n  `;\r\n\r\n      const tarea = this.shadow.querySelector(\".tarea\") as any;\r\n\r\n      tarea.addEventListener(\"click\", (e) => {\r\n        const boton = tarea.querySelector(\".tarea-boton\") as any;\r\n        const label = tarea.querySelector(\".tarea-label\") as any;\r\n        boton.style.visibility = \"visible\";\r\n        tarea.style.backgroundColor = \"blueviolet\";\r\n        label.style.color = \"whitesmoke\";\r\n      });\r\n      //Si quiero escuchar el evento de algunos de los elementos que\r\n      //componen este custom element, tengo que agregar los eventos\r\n      //antes que se renderice el custom element, asi cuando interactue\r\n      //con los elementos que estan dentro del custom element, van a poder\r\n      //ser escuchados y si estos eventos modifican el state y guardan\r\n      //el nuevo state, no abra problemas funcionara todo correctamente.\r\n      //la clave para que sepa con cual customElement estoy interactuando\r\n      //es con el atributo codigo que es unico para cada tarea/elemento\r\n\r\n      //antes de que se ejecute el render voy a crear un evento\r\n      //este evento es cuando realizo un click en el input checkbox\r\n      //voy a modificar el state segun el valor que obtuve del input\r\n      //cuando le realice click\r\n      const checkEl = this.shadow.querySelector(\".tarea-input\");\r\n      checkEl.addEventListener(\"click\", (e) => {\r\n        const target = e.target as any;\r\n\r\n        //si el input checkbox esta\r\n        if (target.checked == true) {\r\n          const cod = this.getAttribute(\"codigo\");\r\n          //primero chequeo si el valor de checked del input es true.\r\n          //guardo el valor del atributo codigo, como este valor es unico\r\n          //voy a recorrer el array de la data.list actualizada y donde\r\n          //coincida los codigos, cambio la tarea a completada,\r\n          // ya que estaba tildada y su valor era true\r\n          //si la destilde con el click etonces voy por el else y hago lo mismo\r\n          //pero con false\r\n\r\n          const ultimaData = state.getState();\r\n\r\n          for (const tarea of ultimaData.list) {\r\n            if (tarea.cod == cod) {\r\n              tarea.completada = true;\r\n            }\r\n          }\r\n\r\n          state.setState(ultimaData);\r\n        } else {\r\n          const cod = this.getAttribute(\"codigo\");\r\n\r\n          const ultimaData = state.getState();\r\n\r\n          for (const tarea of ultimaData.list) {\r\n            if (tarea.cod == cod) {\r\n              tarea.completada = false;\r\n            }\r\n          }\r\n          state.setState(ultimaData);\r\n        }\r\n      });\r\n\r\n      //En este evento voy a modificar el state cuando haga click en el boton eliminar\r\n      //voy a setear como eliminado a la tarea en donde se realizo el click en eliminar\r\n      const botonEliminar = this.shadow.querySelector(\".tarea-boton\");\r\n      botonEliminar.addEventListener(\"click\", (e) => {\r\n        e.preventDefault();\r\n        //sigo la misma logica del evento anterior con respecto al codigo\r\n        const cod = this.getAttribute(\"codigo\");\r\n\r\n        const ultimaData = state.getState();\r\n\r\n        for (const tarea of ultimaData.list) {\r\n          if (tarea.cod == cod) {\r\n            tarea.borrada = true;\r\n          }\r\n        }\r\n        //seteo el nuevo state\r\n        state.setState(ultimaData);\r\n      });\r\n\r\n      this.shadow.appendChild(style);\r\n    }\r\n\r\n    //cuando se agrega el custom element al DOM, el connectedCallback\r\n    //ejecuta la funcion modificaarTarea, con\r\n    connectedCallback() {\r\n      // console.log(\"Custom square element added to page.\");\r\n      modificarTarea(this);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      //  console.log(\"Custom square element removed from page.\");\r\n    }\r\n\r\n    adoptedCallback() {\r\n      // console.log(\"Custom square element moved to new page.\");\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      modificarTarea(this);\r\n    }\r\n  }\r\n\r\n  function modificarTarea(el: any) {\r\n    const shadow = el.shadowRoot;\r\n    shadow.querySelector(\".tarea-label\").textContent =\r\n      el.getAttribute(\"textoMostrar\");\r\n\r\n    let checkedBool: boolean;\r\n\r\n    //verifico que valor tiene el atributo estaChecked, si es false,\r\n    //a la variable checedBool la seteo en false, sino en true\r\n    if (el.getAttribute(\"estaChecked\") == \"false\") {\r\n      checkedBool = false;\r\n    } else {\r\n      checkedBool = true;\r\n    }\r\n\r\n    //luego en el atributo checked del input lo pongo en true o false\r\n    //dependiendo lo que diga la tarea del state\r\n    shadow.querySelector(\".tarea-input\").checked = checkedBool;\r\n\r\n    //le agrago una nueva clase al label, que va a ser si esta checked\r\n    //si esta checked se agragara la clase true, entonces si tiene la clase true\r\n    //en css le tacho el label con line-through, si es false el text-decoration=none\r\n    shadow\r\n      .querySelector(\".tarea-label\")\r\n      .classList.add(el.getAttribute(\"estaChecked\"));\r\n  }\r\n\r\n  customElements.define(\"element-tarea-el\", ElementTareaEl);\r\n}\r\n","import { state } from \"../../state\";\r\nimport { init as initElementTareaEl } from \"../../components/element-tarea\";\r\n\r\nexport function initMiLista() {\r\n  //creo la base de la page, que se trata de un titulo y el form para agregar la nueva tarea\r\n  const div = document.createElement(\"div\");\r\n  div.innerHTML = `\r\n        <h2 class=\"titulo-pincipal\">\r\n          Welcome to the Task-list\r\n        </h2>\r\n        <form class=\"form\">\r\n            <label class=\"label\">\r\n                Nuevo pendiente\r\n                <input class=\"input\" name=\"text\" type=\"text\">\r\n            </label>\r\n            <button class=\"boton-form\">Agregar</button>\r\n        </form>\r\n        <div class=\"container-lista\">\r\n        </div>\r\n        `;\r\n\r\n  //la page se suscribe al state para escuchar sus cambios\r\n  state.subscribe(() => {\r\n    const container = document.querySelector(\".container-lista\");\r\n\r\n    //cada vez que inserto un elemento nuevo, primero borro todo\r\n    while (container.firstChild) {\r\n      container.removeChild(container.firstChild);\r\n    }\r\n\r\n    //data array de las tareas que no esten borradas es una data.list\r\n    const data = state.getTareasNoBorradas();\r\n\r\n    //ahora recorro la lista de las tareas que no fueron eliminadas\r\n    for (const tarea of data) {\r\n      //guardo en una variable las caracteristicas de cada tarea\r\n      const text = tarea.texto;\r\n      const completada = tarea.completada;\r\n      const borrada = tarea.borrada;\r\n      const cod = tarea.cod;\r\n\r\n      //por cada tarea voy a agregar un customElement  <element-tarea-el>\r\n      //con las siguientes propiedades, que son las caracteristicas de la tarea\r\n      //el codigo es muy importante para saber con cual customElent voy a estar interactuando\r\n      const newTareaEl = document.createElement(\"div\");\r\n      newTareaEl.innerHTML = `\r\n        <element-tarea-el textoMostrar=\"${text}\" estaChecked=\"${completada}\" estaBorrado=\"${borrada}\" codigo=\"${cod}\">\r\n        </element-tarea-el>\r\n        `;\r\n\r\n      container.appendChild(newTareaEl);\r\n    }\r\n  });\r\n\r\n  //cuando hago un submit en el form de la nueva tarea, voy a modificar el state\r\n  //haciendo un addItem de una nueva tarea, con completada y borrrada iniciada con false\r\n  //y el texto va a ser lo que ingrese en el imput\r\n  const form = div.querySelector(\".form\");\r\n  form.addEventListener(\"submit\", (e) => {\r\n    e.preventDefault();\r\n    const textInput = e.target as any;\r\n\r\n    const tarea = {\r\n      texto: textInput.text.value,\r\n      completada: false,\r\n      borrada: false,\r\n    };\r\n\r\n    state.addItem(tarea);\r\n  });\r\n\r\n  return div;\r\n}\r\n"],"names":["$0b89d474933103bc$export$ca000e230c0caa3e","data","list","listeners","getState","this","setState","newState","cb","subscribe","callback","push","addItem","item","cs","posicion","length","cod","getTareasNoBorradas","filter","t","borrada","actualState","tareasStingifeado","JSON","stringify","localStorage","setItem","console","log","getItem","ElementTareaEl","HTMLElement","observedAttributes","shadow","attachShadow","mode","constructor","super","render","style","document","createElement","textContent","innerHTML","tarea1","querySelector","addEventListener","e","boton","label","visibility","backgroundColor","color","target","checked","getAttribute","$8f0aa4bc496a6d57$export$2cd8252107eb640b","appendChild","div","container","firstChild","removeChild","tarea","text","texto","completada","newTareaEl","$753bad8f9a484b28$export$10e675146c8e02dc","undefined","listaTareasLocal","parse","$b4e14b6b8da86996$var$main"],"version":3,"file":"index.1e1ab096.js.map"}